---
layout: post
title: "Codeforces Notes" 
description: ""
category: 
tags: [codeforces]
---

719C: Efim and Strange Grade
------------

Idea 1: Simulation (messy !!!)
--------
```
	1. Find the leftmost > 4 digit after the decimal point

	2. from that digit to the left, try apply the rounding until we run out of time

	3. propagate the carry all the way to the leading digit.

```

This approach works, but it is very messy to implement, espeically mixing the rounding and carrying in the same loop


Idea 2: DP
---------
```
	Claim: the final solution is eqivalent of find a prefix of the number, and add 1 to that number, if any rouding is possible

	Proof: by induction, when t = 1, obviously. When t > 1, the carry happens at the digit to the left, so we will not increase the same digit twice, instead, we just move to the left

```

Therefore, we just need to find the prefix to apply the +1 step. This means we need to calculate the minimum time needed to be able to apply rouding on that digit

```
	1. if digit < 4, time(i) = INF	

	2. if digit = 4, time(i) = time(i+1) + 1 

	3. if digit > 4, time(i) = 1;

```

We scan from left to the right to find the first time(i) <= t, and then we add 1 to the prefix 1...i-1. Carrying implmentation is much easier this way


747D: Codeforces 747D: Winter Is Coming
----------

What I did wrong during the contest
-----------
1. Forget the impossible / -1 case, but the fact that have that check for the turing postive tail into negative case suggests such inconsistency is checking of calls means problem.
	
2. My approach to the problem is slightly different. Instead of focusing on the negative segaments, and dirve formula based on that, and I just assume gap + 1 as number of segments, but this formula is wrong when there is no segments at all!

I realized that the special case of last element being negative or not, but instead of using the "last one positive" as base case, I used "last one negative", but this one does not affect the code complexity


749C: Voting 
-----------

What I did wrong during the contest
-----------
```
	1. I thought about simulation, but I was not able to prove it will terminate quickly given 200k input size

	2. I was not able to prove the optimal strategy is indeed optimal

```

Why simulation run time could work
----------
For each vote, the total # of voters is decreased by one. Moreover, if a person is denied,we will remove that person from the line anyway. This means we will iterate through denied person O(n) times, and undenied person O(n) times 


Why the official stragety is optimal
----------
For the first element, assuming R, obviously need to deny one D before the next R.

Now suppose we have RDRDR as we go, with the first D ready to vote,

```
1.If veto the first R, then any D can be vetoed by the next R. Similar argument goes for vetoing the third R

2.If veto the second R, then any D has a chance to not get vetoed, because later D MAY deny further Rs

3. If there is no D after the first D, then it doesn't matter which way we choose, i.e., as long as we pick a strategy and we know it is optimal for this case
```
