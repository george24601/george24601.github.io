---
layout: post
title: "Codeforces notes"
description: ""
category: 
tags: [codeforces]
---


722D: Generating Sets
------------

Since we care about the max number, we can bsearch on that number, and reduce it to the prefix to fall under that, if there is no space, they we know the lowerbound is too low.

Note that my first idea is to be purely greedy: highest number try reducing to the lowest number, but I had difficulty proving it, and it actually failed one of the test cases


682D:  Alyona and Strings (!!!)
------------
This is a classical example where my hard-to-prove greedy solution has an invalid case that I couldn't discover. It turns out a more descriptive DP approach would solve the problem.

I had difficulty discribing the case when a[i] == b[j], this should be a hint where my state is too coarse grained, and should be decomposed more 

if a[i] == b[j], if we take both as the last matching pair, we need to know if it should be glued to a[i-1] and b[j-1], therefore, we need to keep track of the state where if the last pair is used in the output. 


I had problem describing the invalid matching pair with the greedy apporach. With the DP approach I can just pass in an invalid valid (or 0 in this case, since it can't be worse than that), and handle that as part of processing.


if a[i] == b[j]
------------
if we use both, then best(i, j, k, 1) = max(best(i -1, j-1, k -1, 0), best(i-1, j-1, k, 1)) + 1

otherwise, best(i, j, k, 0) = max(best(i - 1, j, k, 0), best(i, j-1, k, 0), best(i-1, j, k, 1)...;


if a[i] != b[j]
----------

best(i,j,k, 0) = max(best(i-1,j, k, 0/1), best(i, j-1, k, 0/1))
