---
layout: post
title: "Educational Codeforces Round 22"
description: ""
category: 
tags: [Codeforces]
---

813B: The Golden Age
----------
Need to take care of long long overflow. I use a log based solution to limit the max value for a and b. The official solution uses 

```
while x <= L/ a
	x *= a;
```

and calculate the powers inside iteration


813D: Two Melodies(!!!)
----------
No obvious way to identify the proper state to keep track of. In this case, we can use the following strategy:
```
1. we focus on actions, starting from base case, and see what states are changed during such actions during such actions.

2. For such hard problem, where we don't even know how to start. Don't worry about final run time constraint right now. Let's fix a solid state and solve it naively, and see if we can use any DS/insight to speed it up 
```
When we are adding a new entry, we have 2 choices, either go to the first sequence, or the second sequence.

Note that we care only the last entry in each sequence, so we just keep track of the last index of each sequence.

How about non-interleaving requirement? The state itself can't capture it. Therefore, we should codify it when we update => to avoid update, we need to append it to either index if possible, but not both.  

In a naive way, we need to iterate through all potential indices. However, we really care only 2 indices;   
1. the most recent j s.t. a[i] %7 = a[j] % 7
2. the most recent j s.t. a[j] + 1 = a[i]



