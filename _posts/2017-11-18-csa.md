---
layout: post
title: "CS Academy Notes"
description: ""
category: 
tags: [csa]
---
Round 37: Fantastic 4
----------
the candiate must be the highest number. Otherwise, we can apply the optimal solution to the highest number to get a better result

So the answer is the get lowest number >= as the second lowest answer,and apply number of  2s to the remaining highest number


Round 37: Reconstruct Graph
---------
Order by the depth, then we know 
1. the depth should be continuous
2. no given edge connects depth >= 2
3. each node has at least one edge connecting to a depth -1 node

so for each node,
ways = 2^ (nodes of same level - existing same level edge)  * (2^ nodes of last level -1 if no connection, or 2^nodes of last level not conect) 


Round 36: Socks Pairs
--------
1. pick one sock for each color
2. start from min to max, check colors of odd #s
3. check the remaing color of even #s

Round 36: Tree Nodes Sets
----------
Keep track of number of insertions and deletions, and traverse down the graph

Round 57: Foxes on a Wheel
----------
Distince between each node is either 1 or 2. So we just try greedily fit as many 1 pairs as possible. The remaining will be 2 distance

Round 57: Distinct Palindromes
----------
How to calcualte the # of pandlndromic subsequence with duplicate:
```
#(l, r) = 0  if l > r
= 1 if l = r
= #(l+1, r) + #(l, r-1) - #(l+1, r-1) if s(l) != s(r), i.e., (L,R) can't be border
= (#(l+1, r) + #(l, r-1) - #(l+1, r-1)) + 1 + #(l+1, r-1)  if s(l) = s(r), i.e., (L,R) can be boarder
```

In the distinct case, first 3 cases are still valid!!! because s(l) != s(r), we know distinct pa starts at l must be different from distinct pa ends at r

in s(l) = s(r) case,we know adding a new border may not introduce a new pa, e.g. aaaaMaaaa, only the outmost a matters! We will have to consider a representitive of each class, instead of counting every single one

So #(L, R, c) = 2 + sum of (#(L-1, R-1, a-z)) => empty + cc + all inner subsequence padded with a



Round 35: Equal Sums
---------
solution is trivial if a[i,j] we know sum of row(i) and sum of col(j) < maxV, i.e., we delay that only if one of them does not satfisfy. 
Note there are max 2N -1 constarints, at each iteration, we will satify at least 1 constraint. Therefore, the loop continues for 2 * N -1 times

I had problem proving why this always works!!!

Implementation
---------
```
    while (1) {
        if (line_sum[line] == mx) {
            line++;
        }

        if (col_sum[col] == mx) {
            col++;
        }

        if (line == n) {
            break;
        }

        int val = mx - max(line_sum[line], col_sum[col]);
        matrix[line][col] += val;
        line_sum[line] += val;
        col_sum[col] += val;
    }

```

Round 34: Max Or Subarray
------------
two pointer scan to keep track of right most i, where we see 1s. Every time we see a new number, we update the list, and calculate the result number, and index intervals 


Round 34: Minimize Max Diff
-----------


