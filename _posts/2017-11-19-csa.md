---
layout: post
title: "CS Academy Notes"
description: ""
category: 
tags: [csa]
---

Round 35:  Least Even Digits
--------
A very hard problem for me!!!

if x has no even digit, infinite

Upper bound: find the last even digit, increase by 1, and make a suffix of 1s. This gives B + 1
Proof: by decreameing 111s, it will reduce # of even digits. However, B+ 1 has strictly less even digits than X

Lower bound: 
No obvious insight possible. Consider a brute force-ish solution to find A-1, the highest number that has < even digits than X
1. we know A - 1 must share a prefix with X
2. we know the digit immediately after the prefix must be less (but we don't which the exact number)
3. after that, the suffix should be a list of 9s, so as not to introduce even digits


Round 33: Div 3
--------
standard greedy solution. Note that we can prove by induction that cost(x) >= cost(y) if x > y


Round 32: Subarray Partition
---------
scan through to calc right[i]
scan through again, maintain currentSegEnd, update it at each right[i], if currentSegEnd = right[i], we know it is the end of the new segment 

Round 32: Square Root Frac (Easy)
--------
No obvious insight. Consider a brute-force solution. We know the number is < 10^5, we just brute force the sqaure of it, and see if the result is an integer


Round 31: Recursive String
---------
need to precompute count(N), so that we can compute char(N, K)

Round 31: Second Minimum
---------

Round 30: Constant Sum
---------

Round 30: Prefix Free Subset
---------


Round 29: Equality
---------


Round 29: Odd Palindromes
--------
