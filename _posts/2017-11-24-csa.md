---
layout: post
title: "CS Academy Notes"
description: ""
category: 
tags: [csa]
---

Round 29: Equality
----------
Note that after each operation, the total sum does not change. Thus, in the extreme case all will be floor(sum/N) or floor(sum/N) + 1. Therefore, the upper cut offline must be in (floor(sum/N) + 1, curMax). 

Moreover, we notice that in this range, there exists a highest possbile upper cutoff line, so we can bsearch on the upper cut off line

Round 29: Odd Palindromes
-----------
1. the format must be of form ABABA..., where odd and even indicies can be considered independently

2. obviously, in the final solution, we want to convert number to current most frequent number.

I got stuck here - suppose I am at i, and the most frequent char is not popular enough, what should I do?!!!  =>

For each i, we just try the most frequenct number in the (L,R), range, if we are unable to, that means we include too much noice, thus, we need to move L to the right by 1, and update the most frequent count


Round 28: Card Shuffle
--------
for each index -i, calculate cycle length. each card appear only once in the cycle  - so linear

Note that the cycle can't have the leading trail problem, because otherwise, the existing one will run into a collsion with the starting one if we run it infinite numbers => i.e., start1 + x * c1 =start2 + x * c2 always exist a solution

Round 28: Water Bottles
--------
Idea 1: 
1. consider the final arragment, we bsearch on the maximum value. The max value range is  min(minValue + residue, maxV) over all is. Min value is the min of max value.

Idea 2: event based!!! 


Round 27: Huge Matrix
--------
standard band overlap problems

Round 27: X Distance
--------
We can consider edge only < X
Consider the case where X = max edge length, then we know a max edge must be a bridge so that it can contribute to a final number. If it is not a bridge, it must be within a cycle


Round 26: Bounded Distinct
--------
small variable of a two pointer problem

Round 26: Build the Towers
--------
1. for first and last element, can only be 0,1,2
2. 1, 2, 3 can NOT be continues by the rule
3. 3 is as powerful as 0 in terms of rule pwoer

Insight I missed: if we built a number, the neighbors smaller than that will be erased to 0!!!

Intuition is that build 0130 is more expensive than 0310, if we scan from left to right.

Experiementing by brute force shows that building higher number than lower number is always cheaper than the lower than higher => some numbers will be preserved


Round 25: Rectangle Path
--------
BFS on rectangle, and ignore the points that could potentially invalid

Round 25: min-ends-subsequence
--------
WLOG, assume left end < right end. We will reverse the array to try both directions.

1. the max subsequence must have left head =  max in the middle + 1. Otherwise, max in the middle is outside the (L, R) range,  we can move the left or right pointer until we find max in the middle + 1 without degrading the answer.

2. the size of the middle subsequence  >= value of lh - index of left head  <= value of lh

3. the target one must have nothing to the left of LH > LH, otherwise, we can move the left pointer to improve that

Therefore, for each i, we need to
1. check if 1,2,3, are satfied to be a candidate

2. given 1,2,3, we need to calcuate the rightmost index of 1,2,3...

3. find if to the right most of the index calucated by 2, we have a number > head, i.e., we also need ot calcualte max number to from i to n
