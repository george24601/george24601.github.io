---
layout: post
title: "atCoder Notes" 
description: ""
category: 
tags: [atCoder]
---

agc001_b: Mysterious Light
----------
Base case x = y, ans = 3 * y

if x > y, ans  = x + y + x + ans (y- x, x). similarly x < y.

Note to improve the performance, we need to do something like the euclidian algorithm, when a < b

```
f(a, b) = 2 * constant * floor(b/a) + f(a, b % a)
```
i.e., skipping the many expanding steps!!!

An even simpler solution is 3 (N - gcd(N, X))





agc001_c : Shorten Diameter
---------
The key insight is the the properties of diameter!!!

1. If d is even, then there exist a point s.t. all distances from v <= d/2

2. if d is odd, then there exists an edge, s.t., all distances from either end of edge <= (d-1)/2

We just try all V/E's and find the maximal graph that satifies this condition 


arc058_b: Iroha and a Grid
----------
Note that H, W <= 100K.  

ways(1,1) -> (H, W) = ways(1,1) -> (i, B + 1) *  ways(i, B + 1) -> (H, W), for all i in [1...A)

First part is choose(i + B, i), second part is choose(H-i + W-B, H-i). Note that official solution uses  (H-A + 1, j) instead



agc002_b: Box and Ball
--------
We need to maintain 
1. cnt for each box

2. at current step, possible for for it to have red ball

3. red ball poitions we have visited

for each move, we mark the next one as possible if cnt[i] > 0 && possible[i]. When cnt[i] = 0, possible[i] becomes false


agc002_c: Knot Puzzle
---------
Consider the last knot we untie, as long as l(i) + l(i+1) > L, we can find a solution. My original guess was too restricted!!!

agc003_b: Simplified mahjong
---------
Claim: for each continous block of cards, we can make floor(S/2) cards!!!
Proof: we list all S cards, and sort them, and we can see that the pair will keep going!!!

So we just scan through each continouous, non-0, subarray, and calculate sum from each side.


agc003_c: BBuBBBlesort!
--------
Claim: answer is # of poistions at odd positions that should go even!!!
Proof: 

arc060_b: Digit Sum
--------


arc060_c: Tak and Hotels
-------
Use two pointer/bsearch to calc, next(i) = rightmost hotel the pointer can reach

agc004_b: Colorful Slimes 
--------


arc061_b: Snuke's Coloring
--------
brute force on all 3 * 3 * 10^5 UL corner of coordniation


arc061_c: Snuke's Subway Trip
--------
