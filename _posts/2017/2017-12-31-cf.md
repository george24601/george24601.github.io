---
layout: post
title: "Codeforces Notes" 
description: ""
category: 
tags: [codeforces]
---

387C: George and Number
---------
The answer is number of non-zero digits

570D: Tree Requests
---------
Do a DFS, keep track of the following things

1. upon visiting each node, add it to the end of the list which is for all nodes at that level - this is where I got stuck!!! The effect is that each list is a left-to-right scan of the tree, i.e., for each node, there exists [l, r] s.t., all nodes in that band are children of that root node.

2. keep track of in/out time of each node, make sure add time by 1 at each in AND out

By 1) and 2), we can see that l >= in time of the root node, and r <= out time of the root node => so just bsearch twice. Use lower_bound!!!

Once we get bound, we can do a prefix sum on each letter, to decide if there is too much odd numbers.

487B: Strip
----------
Just go greedy to expand band from left to right

260C: Balls and Boxes
----------
The last index must have one of the lowest values.

For each candidate, 

1. if i = x, we are good

2. if i > x, then there is no value = min value in the range of [1, i], [x + 1, n]

3. if i < x, then there is min value  in the range of [i+1, x]

so we need to keep track of 
1. left most min value

2. right most min value

3. rightmost min value to the left of x 


432C: Prime Swaps
--------
Calculate all primes <= 10^5, and inverted index for each number. For each number, use bubble sort idea, except that pick the larget prime < distance, and repeats. The prime number is about 10% of all numbers, i.e., we can reduce the distance to 1/10 in each swap => good for 5N requirments

691D: Swaps in Permutation
---------
get all chars and indices in a components, sort the chars and components

35C: Fire Again
---------
Variant of BFS, just keep updating the last.

825D: Suitable Replacement 
--------
Do a bsearch on the final number, find the larget one s.t. number of ?s > missing chars we need to fill

305C: Ivan and Powers of Two
---------
First, preprocess the inputs to remove all duplicates of powers, i.e., for each power, get the count, and then add each binary index to the count of binary + current power

Then we scan from v = 1 to maxV

524C: The Art of Dealing with ATM 
------------
For each request, for each bill, try k1 from 1 to 20, the k2 from 0 to 20 - K1, see if K2 is a possible solution


873C: Strange Game On Matrix
--------
for each column, the band size is fixed, so we can just two pointer to find the highest starting band with max value. The cost is the band sum in [0, optimalStart]

360A: Levko and Array Recovery
--------
make an upper bound for each entry. For op type 1, update the delta array, for op type 2, update the upper bound for the band.

In the end, run the array through the sequence of action again to verify all op2s are still good. 

615C: Running Track
--------
Just brute force, try both forward and backwards for the longest substring that matches the current head. Note that by the greedy approach, it doesn't matter if we matched more in the first then the second => O(n^2)
