---
layout: post
title: "Codeforces Notes" 
description: ""
category: 
tags: [codeforces]
---

612D: The Union of k-Segments
-------
Do a standard event based approach. Note need to handle the tail.

877D: Olya and Energy Drinks
-------
How to improve the naive BFS runtime?!!!

To root cause is there are too many wasted edges => therefore, we try not to store or traverse them.

For each row and col, we keep set of unvisited cells, at each step of BFS, we just keep using lower_bound() and upper_bound() to find and later remove the next cell to visit 

343C: Read Time
-------
bsearch on the seconds. From left to right, calculate the widest band the head can reach

1. if ti < hi, try both left then right or right to left. Can use a set.lower_bound() to find the possible choices

2. if ti >= hi, just go right

637D: Running with Obstacles
---------
```
for oi in 0 to n //add a dummy obstable at 0
	if !reachable[oi] 
		conitinue;
        if dist[oi  + 1] - dist[oi] >= s;		
		while(x[rightId] <= dist[oi + 1] + d)
			rightId++
			reachable[rightId] = true
			from[rightId] =  oi
```

442A: Borya and Hanabi
---------
1. Try all 2^10 guesses, maintain a colorCount for each card, and cardCount for each color, current know cards.

2. for each hint, populate corresponding color/card. every time we fix a point, reduce the unknown count for each color-card, by 1. Note we need to skip the already populated case.

3. Do a recurisve reduction, stops if current know cards = n, or this reduction finds none that can reduce, if only card is known, check if the card has only 1 type of unkown color, if so, mark it as known. if only color is known - similar. If both are unkown, we can try only if only 1 color has 1 unknown cards.

14D:Two Paths
---------
During dijsktra, we keep track of the top 2 shortest edges at each node, with the last edge from different nodes, and also mark which edges are on the dijkstra tree.

After that we scan through all edges again

1. if the edge is on the tree, we check if secondDist[to] + (dist[from] + len(from, to) - l) is bigger than l

2. Otherwise, we check if dist[to] + dist[from] + len(from, to) - l is bigger than l


363D: Renting Bikes
----------
suppose b(i) > b(j), no point to match b(j) before b(i) gets matched. Therefore, the final answer is a band of max K b(i)s.

So we can bsearch on K, and try matching the cheapest K bikes to them, see if the overall cost is <= a

891B: Gluttony
---------
find the inverted index of all values, and shift them to the left by one, i.e., new inverted index for 1 is the old inverted index for 2.

Proof: such shift works because, consider the subset doesn't include the old 1 index,i.e., the new n index, the subset sum of the new one is already greater than the old one

Otherwise, the subset sum is the total sum, which is a constant, mius the subset doesn't include the old 1, which is already different


778B: Bitwise Formula
----------
iterate them bit by bit, use dp to solve the value

514D: R2D2 and Droid Army
----------
since its continous, just use a two pointer to calc shift, use a heap on each col to maintain the max value. not we will allow start = end + 1, to mark invalid ones 

627B: Factory Repairs
---------
looks like fenwicks tree problem

263D: Cycle in Graph
---------
Consier the case where we can not expand the path in DFS ANY LONGER, then all its neighbors must be on the path generated by DFS already!!! so the first vertex on the path marks the start of the cycle, and the cycle has K+1 vertices, i.e., len k + 1

I got stuck here because

534D: Handshakes
---------
!!!

571B: Minimization
----------
!!!

