---
layout: post
title: "On Java volatile keywords" 
description: ""
category: 
tags: [interview, java]
---

1. Volatile forces the program to write the value immediately to the memory in an atomic action by passing cpu cache. reading bypasses CPU cache too, or force the CPU cache to expire early
2. This means if we have only one writer, and all reader/writers are volatile, then the program is thread safe. However, it is not true if you have more than one writer
3. Visibility rule: if the thread reads a volatile value, then ALL variables visible to the thread will be re-read from the memory. This means the order of instructions matter! If you have read AFTER the volatile read, or it got reordered by the compiler, than the vars after the volatile is NOT affected. Luckily, JVM prevents this
4. Note ++ is a syntactic sugar, it is compiled into a read-update-write operation - so you can't use volatile with it!

### Java singleton with volatile

```java

public class Singleton {

private voltile Singleton _instance;

private Singleton() {
}

private Singleton getInstance() {

	if (_instance == null) {
		synchronized(Singleton.class) {
			if(_instance == null)
			  _instance = new Singleton();
		}
	}

	return _instance
}

}
```

### java singleton patterns

```java
class King{

private static King kingInstance;
static {
kingInstance = new King();
}
private King(){
}


public statiic King getKingInstance() {

return kingInstance;

}
}


```

```java

class King{
private static final King kingInstance = new King()

static King getInstance() {
	return kingInstance;
}

private King(){
}

}
```

In theory, the thing below will create multiple instances. 

```java

public static King getKingInstance () {
if(king == null) { 
synchronized (King.class) {
kingInstance = new King()

}

}

return kingInstance;

}

```

### Probably the most optimal singleton

```
public class King {

private King(){

}

//static interanal type will not be instantiated immediately at class loading time
//only be instantiated at getInstance()
//the static property ensures that only the first time class loading will instantiate the process, i.e., JVM guarantees thread-afe for us
private static class KingInstance {
private static final King KINGINSTNACE = new King();
}

public static King getInstance(){
return KingInstance.KINGINSTANCE;
}

}

```
