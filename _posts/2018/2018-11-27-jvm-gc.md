---
layout: post
title: "On JVM GC"
description: ""
category: 
tags: [jvm, interview]
---

### Concepts
* safe point: points where you can pause user thread,i.e., needed for GC
* safe area: for sleep or blocked threads. In the code, reference relationship won't change
* Scavengc GC: triggered when Eden failed get more space. Eden region only

### GC roots

* referred by local variables and operand stacks in jvm stack frame
* method area, referred by class static
* method area, referred by constant
* local method stack, referred by JNI

### Copying GC
* Use only half of space, gc, and then move the survior into the other region, so that the other region has no frag
* Often used by new gen,e.g.,  Serial, ParNew, Parrallel Scanvenge (at new gen), Serial old (for old gen), because new gen has less surviors and more garbages than older gen

### Compacting GC
* move live objects toward one end of the heap. Note this idea is similar to Copying GC but NOT same!
* may use a table of object handles, so that only handle -> actual actual address needs updated during copyign
* Good for old gen where relativly less garbages exist,i.e., less need to move
* Used in Mark-compact, which is common for old gens

### Mark and Sweep GC
* Separate of mark phase and sweep stage (and potentially compact stage to defrag), often used for old gen. Will stop the world and generate memory fragments
* For each unreferenced objects, need to also mark if the finalizer has been run or not. The sweep phase will include finalization. Therefore, object may be resurrected by finalizer which makes the object reachable, and GC can not decide if change the object back to reachable to unreachable until after all resurrectable objects' finalizers are run
* Parallel Scanvenge at old gen, Parallel old, 

### CMS
* shortest stop time.
* tag objects directed referenced by GC roots
* use GC root tracing to tag all garbages, user thread still running
* Remark: fix changed introduced during the concurrent tag stage
* concurrently use tag-cleanup to clean the garbage object, user thread . By default, will defrag first
* By default GC thread 3 = (CPU + 3) /4
* Still need to mark & sweep for old ge


### [G1/Garbage First](http://george24601.github.io/2019/01/03/g1-gc.html)


### Method area gc
Decide if constant and types are still in use. Need to satify ALL of

* all instance are gced
* the ClassLoader for this type is gced. Hence, types (not its instances!) loaded by the bootstrap classloader is never gced
* java.lang.Class object for that type is not referenced/unreachable at all


### Generational GC

The young generation is divided into Eden/From Survivor(S0)/To Survivor(S1). Size ratio 8:1:1, default to 1/15 of the heap size

* The majority of newly created objects are located in the Eden space. Use copying GC
* After a GC in the Eden space, the objects are piled up into the Survivor space, where other surviving objects already exist.
* If (Eden + From Surivior) obj size < To Survivor space, move them to To Surivior, otherwise, move them to old gen directly. increase these To Survivor object age by 1, when it hits age 15, they enter old gen
* After minor GC, if Eden is not enough to for the new object, the new object goes to old gen directly
*  > To Surivior half size, and with equal age, any objects older than this age enter the old gen
* when doing minor GC, will determin if old gen's max continious space > total object sizes in the new gen, this is ONE of the steps of deciding if we should do full gc instead
* For high throughput requirement, more likely to have bigger young gen and smaller old gens, so that most short term objects can be gced ASAP


### Bump the pointer(BP) vs TLABs (Thread-Local Allocation Buffers)

* BP just keep track of top pointer in Eden, and see if the new object can fit it in before updating the pointer
* But in a multi-thread case, BP will cause lock contention. Therefore, TLAB gives each thread a small, thread-local space in Eden

### Old gen obj refering to young gen

* Use a 512 byte card table to record which old gen objects are referring to young gen
* managed by a write barrier

### Train algorithm

* each gen divided into blocks of same size
* each gc runs only on one block
* for objects promoted to older gen, they are added to the tail of the older gen's train
