---
layout: post
title: "Debugging JVM memory issues"
description: ""
category: 
tags: [interview, java]
---

### Is the survivor space enough?
If not, then after minor GC, the objects can't fit into the survivor, and we will have to promote to old gen directly. Consider making new gen 50% bigger than the old gen

### Which GC to use?
ParNew for new gen, CMS for old gen. 

### Metaspace full
* commonly caused by too many proxies generated by cglib
* By default the size is about 20M, and then on start this size is very likely to trigger metaspace resize, which leads to GCs. Consider setting metaspace size to min=max=256MB

### Native memory usage too high
e.g., off heap memory such as DirectByteBuffer

### Where are strings stored?
* Constant strings are stored in string constant pool, which is on the heap. It is implemented as a hashtable of pointers to the strings on the heap
* Other strings created by ctor just stay on heap as usual

### Tools

1. `jmap -heap` - check new and old jen size
2. `jmap -histo:live` - what is alive, is it too much?
3. `/proc/${PID}/fd`, `/proc/${PID}/task`
4. pstree„ÄÅss - to check process creation and network connection number
