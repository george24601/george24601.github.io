---
layout: post
title: "Atcoder notes"
description: ""
category: 
tags: [atcoder]
---

### [D - Coloring Edges on Tree](https://atcoder.jp/contests/abc146/tasks/abc146_d)

The official approach is cleaner than mine

* We know that answer >= deg(v). In fact, max(deg(v)) is sufficient to give a solution 
* We can just BFS, add keep assigning the color form 1 to K while skipping the color of the edge from grand parent to parent. Such construction ensures the conditions are satisfied
* Note that DFS is not feasible here because we lose the coloring information on siblings

### [E - Colorful Hats 2](https://atcoder.jp/contests/sumitrust2019/tasks/sumitb2019_e)


The key insight is that given colors in 1...i, the color in i+1, can be uniquely determined by picking one color same as the predecessor. The mulitplication factor acts as the "pick"

Index 0 acts as the sentinel value

I got WA in formula - tried to classify 2 color and 3 color case. This implys at the each index, the pick is not unique even with the multiplier - classic anti pattern


### [D - Lucky PIN](https://atcoder.jp/contests/sumitrust2019/tasks/sumitb2019_d)

The official brute force solution is cleaner than mine

```python

for i in range(100):
	ds = [i/100, (i/10)%10, i% 10]
	find = 0 
	for i in range N:
		if match:
			find+=1

	if find == 3:
		ans+= 1

```

It also has a DP approach with 240M ops and 240M memory


### [C - HonestOrUnkind2](https://atcoder.jp/contests/abc147/tasks/abc147_c)

The official soultion is cleaner than mine. Mainly because even if I used bitmask, I still use a second array to track correctness, which is not needed, due to the bit mask

### [B. Counting of Trees](https://atcoder.jp/contests/nikkei2019-2-qual/tasks/nikkei2019_2_qual_b)

For reason unknown, i implemented count in a very verbose way...Just a simply dict and update is enough. Although, I missed the check where D[0] has to be 0 due to the condition in the problem

### [D. Disjoint Set of Common Divisors](https://atcoder.jp/contests/abc142/tasks/abc142_d)

The answer is the prime factorization of the GCD. Note that prime factorization can run in sqrt(N), and after sqrt(N), if the number is not 1, then we know that number is the only divisor left, and it is prime.

Proof: by contradiction
* suppose that remaining number is not prime, then we should have divied it in the previous step, where all divisors no more than sqrt(N) have been discoverd
* Because it is prime, we know it is the only possible divisor left, otherwise, it would be a product of two divisors > sqrt(n) => contradiction
* Note by this proof, during coding we don't have to limit the upperbound to tight sqrt(n), as long as we exhause all divisors under an upperbound it still holds




