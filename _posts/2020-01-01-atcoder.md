---
layout: post
title: "Atcoder notes"
description: ""
category: 
tags: [atcoder]
---

### [D - Coloring Edges on Tree](https://atcoder.jp/contests/abc146/tasks/abc146_d)

The official approach is cleaner than mine

* We know that answer >= deg(v). In fact, max(deg(v)) is sufficient to give a solution 
* We can just BFS, add keep assigning the color form 1 to K while skipping the color of the edge from grand parent to parent. Such construction ensures the conditions are satisfied
* Note that DFS is not feasible here because we lose the coloring information on siblings

### [E - Colorful Hats 2](https://atcoder.jp/contests/sumitrust2019/tasks/sumitb2019_e)


The key insight is that given colors in 1...i, the color in i+1, can be uniquely determined by picking one color same as the predecessor. The mulitplication factor acts as the "pick"

Index 0 acts as the sentinel value

I got WA in formula - tried to classify 2 color and 3 color case. This implys at the each index, the pick is not unique even with the multiplier - classic anti pattern


### [D - Lucky PIN](https://atcoder.jp/contests/sumitrust2019/tasks/sumitb2019_d)

The official brute force solution is cleaner than mine

```python

for i in range(100):
	ds = [i/100, (i/10)%10, i% 10]
	find = 0 
	for i in range N:
		if match:
			find+=1

	if find == 3:
		ans+= 1

```

It also has a DP approach with 240M ops and 240M memory


### [C - HonestOrUnkind2](https://atcoder.jp/contests/abc147/tasks/abc147_c)

The official soultion is cleaner than mine. Mainly because even if I used bitmask, I still use a second array to track correctness, which is not needed, due to the bit mask
